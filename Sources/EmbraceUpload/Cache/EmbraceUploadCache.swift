//
//  Copyright Â© 2023 Embrace Mobile, Inc. All rights reserved.
//

import Foundation
import GRDB

/// Class that handles all the cached upload data generated by the Embrace SDK.
class EmbraceUploadCache {

    private(set) var options: EmbraceUpload.CacheOptions
    private(set) var dbQueue: DatabaseQueue

    init(options: EmbraceUpload.CacheOptions) throws {
        self.options = options

        // create base directory if necessary
        try FileManager.default.createDirectory(at: options.cacheBaseUrl, withIntermediateDirectories: true)

        // create sqlite file
        dbQueue = try DatabaseQueue(path: options.cacheFilePath)

        // define tables
        try dbQueue.write { db in
            try UploadDataRecord.defineTable(db: db)
        }

        try clearOldData()
    }

    /// Fetches the cached upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    /// - Returns: The cached `UploadDataRecord`, if any
    public func fetchUploadData(id: String, type: EmbraceUploadType) throws -> UploadDataRecord? {
        try dbQueue.read { db in
            return try UploadDataRecord.fetchOne(db, key: ["id": id, "type": type.rawValue])
        }
    }

    /// Fetches all the cached upload data.
    /// - Returns: An array containing all the cached `UploadDataRecords`
    public func fetchAllUploadData() throws -> [UploadDataRecord] {
        try dbQueue.read { db in
            return try UploadDataRecord
                .order(Column("date").asc)
                .fetchAll(db)
        }
    }

    /// Removes old data from the cache. Configured through `EmbraceUploadCacheOptions`'s `cacheDaysLimit`.
    public func clearOldData() throws {
        guard options.cacheDaysLimit > 0 else {
            return
        }

        let secondsPerDay: TimeInterval = 60 * 60 * 24
        let limitDate = Date(timeIntervalSinceNow: -(TimeInterval(options.cacheDaysLimit) * secondsPerDay))

        try dbQueue.write { db in
            let recordsToDelete = try UploadDataRecord.filter(Column("date") < limitDate)
                .fetchAll(db)

            for recordToDelete in recordsToDelete {
                try recordToDelete.delete(db)
            }
        }
    }

    /// Saves the given upload data to the cache.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - data: Data to cache
    /// - Returns: The newly cached `UploadDataRecord`
    @discardableResult func saveUploadData(id: String, type: EmbraceUploadType, data: Data) throws -> UploadDataRecord {
        let record = UploadDataRecord(id: id, type: type.rawValue, data: data, attemptCount: 0, date: Date())
        try saveUploadData(record)

        return record
    }

    /// Saves the given `UploadDataRecord` to the cache.
    /// - Parameter record: `UploadDataRecord` instance to save
    func saveUploadData(_ record: UploadDataRecord) throws {
        try dbQueue.write { [weak self] db in

            // update if its already stored
            if try record.exists(db) {
                try record.update(db)
                return
            }

            // check limit and delete if necessary
            if let limit = self?.options.cacheLimit, limit > 0 {
                let count = try UploadDataRecord.fetchCount(db)

                if count >= limit {
                    let recordsToDelete = try UploadDataRecord
                        .order(Column("date").asc)
                        .limit(Int(limit))
                        .fetchAll(db)

                    for recordToDelete in recordsToDelete {
                        try recordToDelete.delete(db)
                    }
                }
            }

            try record.insert(db)
        }
    }

    /// Deletes the cached data for the given identifier.
    /// - Parameters:
    ///   - id: Identifiar of the data
    ///   - type: Type of the data
    /// - Returns: Boolean indicating if the data was successfuly deleted
    @discardableResult func deleteUploadData(id: String, type: EmbraceUploadType) throws -> Bool {
        guard let uploadData = try fetchUploadData(id: id, type: type) else {
            return false
        }

        return try deleteUploadData(uploadData)
    }

    /// Deletes the cached `UploadDataRecord`.
    /// - Parameter uploadData: `UploadDataRecord` to delete
    /// - Returns: Boolean indicating if the data was successfuly deleted
    func deleteUploadData(_ uploadData: UploadDataRecord) throws -> Bool {
        try dbQueue.write { db in
            return try uploadData.delete(db)
        }
    }

    /// Updates the attempt count of the upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - attemptCount: New attempt count
    /// - Returns: Returns the updated `UploadDataRecord`, if any
    @discardableResult func updateAttemptCount(id: String, type: EmbraceUploadType, attemptCount: Int) throws -> UploadDataRecord? {
        guard let uploadData = try fetchUploadData(id: id, type: type) else {
            return nil
        }

        try updateAttemptCount(uploadData: uploadData, attemptCount: attemptCount)

        return uploadData
    }

    /// Updates the attempt count of the given `UploadDataRecord`
    /// - Parameters:
    ///   - uploadData: `UploadDataRecord` instance to update
    ///   - attemptCount: New attempt count
    func updateAttemptCount(uploadData: UploadDataRecord, attemptCount: Int) throws {
        var record = uploadData

        try dbQueue.write { db in
            record.attemptCount = attemptCount
            if try record.exists(db) {
                try record.update(db)
            }
        }
    }
}
